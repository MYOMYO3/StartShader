# StartShader

Kim Pope님의 책 [셰이더프로그래밍 입문] 책을 보며 공부했던 내용입니다.

압축파일 안에는 챕터별로 폴더가 있고, 각 폴더에는 솔루션 파일과 렌더몽키 실행파일이 있습니다.

렌더몽키 실행파일로 정점셰이더와 픽셀셰이더 코드를 보실 수 있습니다.

아래 그림은 셰이더의 개념과 각 챕터별 결과화면입니다.

### Chaper1.

**1.셰이더란?**

 ■ 어휘적 접근 : 픽셀의 농담, 색조, 명암을 결정하는 주체

 ■ 구조적 접근 : 정점셰이더 : 투시 / 픽셀셰이더 : 명암![img](https://lh4.googleusercontent.com/f46fnpmkKQiN80jVeIv-p__iMWcuoiqMfIg2YyhbDZQuj8aHjIT87Ltu4xUAQzwyx72vKJVrHpLofVwQ_KBSZ8ZpH49ZHANlK6M47jXU1sAEgndV-_73Hll3Q1K2YK0cyyCcGf6H)


● 셰이더는 어느 픽셀을 어떤 색으로 칠할지를 계산하는 함수이다.

● 셰이더를 화가가 그림을 그리는 것에 비교하면 정점셰이더는 투시를, 픽셀셰이더는 명암을 담당한다.

● 셰이더프로그래밍이란 정점셰이더와 픽셀셰이더에서 실행시킬 함수를 작성하는 것이다.

● AMD사의 렌더몽키를 사용하면 빠르게 셰이더를 프로토타입할 수 있다.

<br><br><br>

### **Chaper2.**

기본적인 빨강색 셰이더입니다

![img](https://github.com/wjdgh283/ShaderProgramming/blob/master/img%20rcs/2.JPG?raw=true)

● 각 정점마다 변하는 값은 정점데이터 멤버변수로 받는다.

● 모든 정점에 공통적으로 사용되는 값은 전역변수로 받는다.

● HLSL은 벡터연산에 편리하게 사용할수 있는 여러가지 자료형을 제공해준다.

● 정점의 공간을 변환할 때는 행렬 곱을 사용한다. HLSL에서 제공하는 내장함수 mul()을 사용하면 손쉽게
  행렬과 벡터를 곱할수 있다.
  
● HLSL에서 색상을 표현할때는 0~1사이의 정규화한 값을 사용한다.

<br><br><br>

### **Chaper3.**

물체표면을 단색으로 출력하지 않고, 텍스처를 입히는 텍스처매핑입니다

![img](https://github.com/wjdgh283/ShaderProgramming/blob/master/img%20rcs/3.JPG?raw=true)

● 텍스처매핑을 하려면 UV 좌표가 필요하다.

● UV좌표는 각 정점 상에 정의된 가변 값이다.

● 픽셀셰이더가 정점데이터를 이용하려면 정점셰이더의 도움이 필요하다.

● 정점셰이더가 출력하는 값은 모두 보간기(레스터라이저)를 거친다.

● tex2D 함수를 이용하면 쉽게 텍스처를 샘플링할 수 있다.

<br><br><br>

### **Chaper4.**

광원을 추가하여 정반사광과 난반사광을 표현한 셰이더입니다.

![img](https://github.com/wjdgh283/ShaderProgramming/blob/master/img%20rcs/4.JPG?raw=true)

● 람베르트 모델은 난반사광을 계산하는 기법으로 코사인함수를 사용한다.

● 퐁 모델은 정반사광을 계산하는 기법으로 코사인 값을 거듭제곱 한다.

● 벡터의 길이를 1로 바꾸면 내적을 구하는 것만으로도 코사인 함수를 대신할 수 있다.

● 동일한 계산을 어느 쪽에서라도 할 수 있다면 픽셀셰이더보다는 정점셰이더에서 한다.

● 이 장에서 배운 조명보다 훨씬 사실적이고 복잡한 기법들이 존재한다. 그중 일부는 이미 몇몇게임에서 쓰이고 있다.

<br><br><br>

### **Chaper5.**

난반사광과 정반사광에 텍스처를 적용한 디퓨즈/스페큘러 매핑입니다. 

![img](https://github.com/wjdgh283/ShaderProgramming/blob/master/img%20rcs/5.JPG?raw=true)

● 인간이 물체의 색을 볼수 있는 이유는 물체마다 흡수 및 반사하는 빛의 스펙트럼이 다르기 때문이다.

● 3D 그래픽에서는 디퓨즈맵과 스페큘러맵을 사용하여 빛의흡수반사를 재현한다.

● 스페큘러맵은 각 픽셀마다 정반사광을 조절하는 것을 주 목적으로 한다.

● 빛의 색도 물체의 최종색에 기여한다.

● 텍스처는 색상 정보만을 저장하는 것이 아니다. 스페큘러맵의 경우가 그 예이다.(법선매핑도 있다.)

<br><br><br>

### **Chaper6.**

만화같은 명암을 입히는 툰셰이더입니다. 명암처리를 부드럽게 하는대신 2~3단계로 딱딱 끊어서 표현하였습니다.

![img](https://github.com/wjdgh283/ShaderProgramming/blob/master/img%20rcs/6.JPG?raw=true)

● 툰셰이더는 비실사 렌더링 기법 중에 하나이다.

● 툰셰이딩은 난반사광을 단계적으로 감소시키는 것에 지나지 않는다.

● 행렬들을 미리 곱해놓으면 공간변환을 더 빨리 할수 있다.

<br><br><br>

### **Chaper7.**

폴리곤 수를 늘리지 않고도 표면의 울퉁불퉁한 효과를 추가하는 법선매핑을 적용한 결과입니다. 표면 위에서 법선이 어떻게 정의되어 있는냐에 따라서 조명효과가 결정됩니다.

![img](https://github.com/wjdgh283/ShaderProgramming/blob/master/img%20rcs/7.JPG?raw=true)

● 인간이 물체의 질감을 인식하는 것은 대부분 명암효과 때문이다. 따라서 평면에서 법선의 방향만 바꿔줘도 
  물체의 입체감을 표현할수 있다.
  
● 이렇게 폴리곤의 수를 늘리는 대신 각 픽셀마다 법선을 정의해주는 기법이 법선매핑이다.

● 법선맵은 접선공간(표면공간)으로 저장하는 것이 보통이다.

● 접선공간에 있는 법선벡터를 조명계산에 사용하려면 공간변환이 필요하다.

● 접선공간의 공간변환에 사용할 행렬은 정점의 법선, 접선, 종법선을 조합하여 만든다.

<br><br><br>

### **Chaper8.**

입방체 텍스처를 추가하여 환경매핑을 한 결과입니다. 즉 거울처럼 주위환경이 표면에 반사되는 걸 재현한 것입니다. 주위환경을 미리 텍스처 안에 저장해 놓은 뒤, 실행도중 실시간으로 그 텍스처를 입히는 원리입니다. 환경매핑은 주위에 있는 물체가 반사한 빛이 거울 같은 표면에 정반사되는 것입니다.

![img](https://github.com/wjdgh283/ShaderProgramming/blob/master/img%20rcs/8.JPG?raw=true)

● 거울같은 표면을 표현하는 기법으로 환경매핑이 있다.

● 환경매핑은 간접광을 재현하는 방법중 하나이다.

● 입박체 텍스처만 미리 만들어 놓으면 쉽게 환경매핑을 할 수 있다.

<br><br><br>

### **Chaper9.**

UB애니메이션으로 울렁이는 효과를 재현해낸 것입니다. 시간이 흐름에 따라 U좌표에 더해주는 값을 서서히 증가시키거나 빼주면 텍스처를 좌우로 움직일 수 있게 됩니다. 추가로 정점의 위치가 위아래로 출렁이게 하기 위해 정점위치에 Y값을 적당히 증감해주었습니다.

![img](https://github.com/wjdgh283/ShaderProgramming/blob/master/img%20rcs/9-1.gif?raw=true)

● 시간에 따라 UV좌표의 값을 증감시키면 단단한 UV애니메이션을 만들 수 있다.

● 여러 매개변수에 따라 정점의 위치를 왜곡시키는 방법도 융용할 때가 있다.

● 셰이더에서 사용하는 연산자를 변수로 정해두면 재빨리 여러값들을 바꿔가며 실험해 볼 수 있다.

<br><br><br>

### **Chaper10.**

그림자 기법을 평정한 그림자매핑입니다. 다음과 같은 순서로 셰이더를 만듭니다.

1. 그림자생성단계
   - 렌더링 결과(빛을 가로막는 첫 번째 물체의 깊이)를 저장할 렌더타겟을 정해 준다.
   - 카메라를 광원의 위치에 두고 물체들을 그린다.
   - 픽셀셰이더에서 빛으로부터 현재 픽셀까지의  깊이를 반환한다.
2. 그림자 적용단게
   - 렌더링 결과(일반 장면 렌더링)을 화면(백버퍼)에 저장한다.
   - 카메라를 눈의 위치에 두고 물체들을 그린다.
   - 빛으로부터 현재 픽셀까지의  깊이를 그림자맵에 담겨있는 결과와 비교한다. 현재 깊이가 그림자맵의 깊이보다 크면 그림자를 씌운다.

![img](https://github.com/wjdgh283/ShaderProgramming/blob/master/img%20rcs/10.JPG?raw=true)

● 그림자는 어떤 물체가 빛을 막아서 생기는 현상이다.

● 빛을 막는 물체가 여럿 있을 경우 처음에 빛을 막는 물체만이 의미를 갖는다.

● 그림자맵은 빛을 처음 막는 물체의 깊이(광원으로부터의 깊이)를 기억한다.

● 이 깊이와 현재 픽셀의 깊이를 비교하면 현재 픽셀이 '처음으로 빛을 막는 물체' 인지를 쉽게 알 수 있다. 
  그렇지 않다면 그림자를 씌운다.

● 렌더타겟을 이용하면 렌더링 결과를 텍스처에 저장할 수 있다.

<br><br><br>

### **Chaper11.**

세피아 / 흑백사진 효과입니다. 장면을 그린 뒤, 그 결과를 2D이미지로 가져다가 한번에 고쳐버리는 원리입니다.

![img](https://github.com/wjdgh283/ShaderProgramming/blob/master/img%20rcs/11-1.JPG?raw=true)

![img](https://github.com/wjdgh283/ShaderProgramming/blob/master/img%20rcs/11-2.JPG?raw=true)

● 포스트프로세싱이란 장면을 2D 텍스처에 그린 다음 그 위에 영상처리 기법을 입히는 것이다.

● 포스트프로세싱을 이용하면 쓸데없이 셰이더의 수를 늘리는 것을 막을 수 있다.

● 화면 가득 픽셀을 그리려면 화면을 가득 채우는사각형을 그린다.

<br><br><br>

### **Chaper12.**

외곽선 찾기 / 양각효과 입니다. 배경과 물체의 색이나 명암이 다르면 물체의 외곽선을 볼 수있게 한 결과입니다. 현재 픽셀을 중심으로 해서 그 주위에 있는 픽셀마다 가중치를 곱한 뒤, 그 결과를 모두 더한 값으로 현재 픽셀의 값을 변경하는 컨벌루션 연산을 이용합니다.

![img](https://github.com/wjdgh283/ShaderProgramming/blob/master/img%20rcs/12-1.JPG?raw=true)

![img](https://github.com/wjdgh283/ShaderProgramming/blob/master/img%20rcs/12-2.JPG?raw=true)

<br><br><br>

### **기타 포스트이펙트 기법**

● HDR(High Dynamic Range) 효과 : HDR은 보통 블룸과 톤매핑을 포함합니다. 나뭇가지 사이로 태양을 바라보면 태양빛이
  너무 강렬해서 나뭇가지가 보이지 않을 정도가 되죠? 이게 블룸입니다. 톤매핑이란 이것보다 조금 더 설명하기 어려운데,
  대낮에 방안에서 창을 배경으로 인물사진을 찍으면 바깥은 잘보이는데 얼굴은 너무 어두운 경우가 있죠? 사람 눈에는 둘다 
  선명하게 보이는데 사진만 찍어놓으면 그 꼴이 되지요. 이런 경우 사람 눈처럼 어두운 곳과 밝은 곳을 모두 잘보이게 만드는게
  톤 매핑입니다.
  
● 비니엣 효과 : 영화 같은 거 보면 화면 가장자리에 울렁이는 검정테두리를 보신적이 있나요? 이게 비니엣 효과입니다.

● DOF(depth of filed)효과 : 카메라의 초점이 가까이에 있으면 멀리 있는 물체가 흐릿해지고, 초점이 멀리 있으면 가까이 있는 것이
  흐릿해지는 효과입니다.
  
● SSAO(screen space ambient occlusion, 화면공간 주변광차폐)기법 : 법선정보와 깊이 정보 등을 렌더타겟에 저장 한뒤, 이들을 이용
  하여 물체 사이에 주변광이 차폐되는 정도를 계산하는 방법입니다.
  
● 잔상(motion blur)효과 : 얼굴을 좌우로 재빨리 돌리면 배경이 번져 보이죠? 마찬가지로 카메라가 움직이는 정도에 따라 저번 프레임과
  현재프레임을 블렌딩하는 방법입니다.
